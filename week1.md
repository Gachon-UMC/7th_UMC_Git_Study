# Git-Study_Week1
## 1. Git의 정의와 사용 이유
### 1-1. Git이란?
분산 버전 관리 시스템

### 1-2. 사용 이유
파일의 변경 사항을 `추적`하고 여러 사용자 간의 파일과 작업들을 `조율`하기 위해

## 2. 파일 관리 시스템
### 2-1. 저장소(repository)
작업하는 파일들이 저장되는 폴더
- 로컬 저장소(local repo): 내 컴퓨터에 위치
- 원격 저장소(remote repo): 깃허브에 위치
로 나뉨

### 2-2. Working Directory
내가 현재 작업하고 있는 공간
기본적으로 변경 사항이 모두 추적됨
변경 사항이 추적되지 않는 파일들도 있음
- `gitignore` 파일: 토큰, 서버의 BaseURL 또는 충돌 위험이 있는 파일 같은 공유하지 않는 파일을 이곳에 넣어 추적되지 않게 처리

### 2-3. Staging Area
`staged` 상태의 파일들이 있는 곳

#### 파일들의 상태 종류
- `unmodified`: 변경되지 않은 파일
- `modified`: 변경된 파일
- `staged`: 커밋을 위한 준비 단계 (변경된 파일 중 선택적으로 `stage`하여 해당 파일만 커밋할 수 있도록 하는 것)

### 2-4. Local Repository
`commit`을 통해 파일의 변경 사항을 기록하는 곳
이후 `push` 명령어를 통해 로컬 레포의 변경 사항을 원격 레포에 반영

- `add`: `modified`된 파일을 `stage`하는 것
- `commit`: `staging area`에 올라가 `staged` 상태가 된 파일의 체크포인트를 만드는 것

## 3. Git 사용 방법
### 3-1. 원격 레포 생성 후 로컬 레포와 연결
* `GitHub` 로그인
* `Repositories` 클릭
* 오른쪽 상단의 `New` 버튼 클릭
* `Repository name(레포 이름, 로컬 레포와 연결 시 최상위 폴더의 이름이 됨)`, `Description(레포의 부가적인 설명 부분)`, `Public(공개)`/`Private(비공개)` 등의 필수적인 정보들 입력 [레포 생성 시 `Add a REDME File`을 체크하면 경고가 뜨지 않음]
* `Create repository` 버튼 클릭
* 원격 레포의 링크 복사
* 로컬 내에서 연결할 폴더 위치에서 터미널 실행
* 폴더 위치의 터미널 내에서 `git clone (레포 주소)` 명령어 실행

### 3-2. `.gitignore`로 파일 관리
`gitignore`파일: 추적되지 않아야 하는 파일 목록을 지정하는 파일
- `.gitignore` 파일 생성
- 파일 내에 추적 해제할 파일을 작성한 뒤 저장
- 확장자를 추적 해제해야 할 시
```.(확장자 이름) # ex_ .(txt)```
이런 형식으로 작성
- 폴더를 추적 해제해야할 시
```folder_name/```
이런 형식으로 작성

*`gitignore.io`라는 사이트를 이용힌 자동 생성도 가능

### 3-3. `add`, `commit`, `push` 명령어
#### `add` 명령어
 ```git add .```
모든 파일을 `staged` 상태로 변경
 ```git add (파일 이름)```
특정 파일만 골라서 `staged` 상태로 변경

#### `commit` 명령어
이번 커밋에서 어떤 작업을 했는지 작성하는 명령어

```git commit -m "(커밋 메세지)"```
이런 형식으로 작성

#### `push` 명령어
로컬 레포에 반영된 내용을 원격 레포로 보내기 위한 명령어

```git push origin (브랜치 이름)```
이런 형식으로 사용

* `origin`: 원격 레포의 URL을 담고 있는 키워드

### 3-4. 내 파일 상태 확인
```git status```
이 명령어를 사용하여 확인
* 파일이 커밋 되었는지, 추적 해제 되었는지 등의 상태 확인 가능

## 4. Branch
### 4-1. 브랜치란?
한 시점에서 서로에게 영향을 주지 않는 작업을 진행하기 위해 생성하는 분기
각자 작업해서 합치는 과정에서 서로에게 영향을 끼치지 않게 하기 위해 사용
기본 브랜치는 보통 `main`으로 설정

### 4-2. 브랜치 생성 후 전환 방법
* 브랜치 생성 명령어
```git branch (브랜치 이름)```
* 브랜치 이동 명령어
```git checkout (브랜치 이름)``` 또는 ```git switch (브랜치 이름)```
`checkout` 명령어가 브랜치를 이동시키는 `switch`와 파일의 수정 내용을 복원하는 `restore`로 나뉘었기 때문에 되도록 `switch` 명령어를 사용할 것 (단, 꼭 작업 내용을 커밋한 후 진행)

### 4-3. 브랜치 merge
```git merge (병합할 브랜치)```
현재 브랜치에서 다른 브랜치의 변경사항을 현재 브랜치에 적용시킬 때 사용하는 명령어
* 충돌 위험이 있어 `Pull Request`를 작성한 후 병합 여부를 결정

## 5. 커밋 기록 확인
### 5-1. `git log` 조회
```git log```
이 명령어를 사용하여 커밋 기록을 조회

커밋의 구성들
* 커밋 해시: 커밋을 구분하기 위한 고유한 ID
* 커밋 생성자: 커밋을 생성한 사람
* 커밋 일시: 커밋이 생성된 시간대
* 커밋 메세지: 입력한 커밋 메세지

### 5-2. `HEAD`
내 브랜치의 가장 최신 주소(현재 브랜치의 최신 커밋을 참조하는 값)

## 6. `Issue`와 `PR`
### 6-1. `Issue`
협업 진행 시 작업 진행 현황과 기능 구현, 버그 수정, 리팩토링 등을 구현하기 위해 생성

#### 구성
* `제목`: 작업 태그(feature/fix/refactor/style 등의 작업 유형 - 컨벤션에 따라 달라짐)
* `내용`: 작업할 내용 혹은 to-do (컨벤션에 따라 달라짐)
* `Assignees`: 이슈를 작업할 담당자가 할당되는 부분
* `Labels`: 작업 태그가 할당되는 부분
* `Projects`/`Milestone`: 더 큰 단위의 작업 내용을 작성 가능한 부분
* `Development`: 이슈, 연결된 브랜치 또는 PR 연결 가능

### 6-2. `Pull Request`
작업한 내용을 메인 브랜치로 반영할 때 작성
메인 브랜치에세 `Pull` 받아줄 것을 요청
구성은 `Issue`와 유사함

* `Reviewers`: 리뷰가 필요한 상황에서 특정 인물을 리뷰어로 추가 가능